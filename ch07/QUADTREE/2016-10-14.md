## QUADTREE

- 코드수정 0번
- 제출 1번
- 소요시간 1시간 10분
- 문제 해결 성공

### 접근방법
분할 정복을 사용해 문제를 해결함

#### 분할
주어진 쿼드트리를 더 작은 쿼드트리 **4개**로 나눈다.

#### 병합
4개의 쿼드트리의 위치를 상하반전시켜 합친다.

#### 기저사례
1. 주어진 쿼드트리가 w이거나 b인 경우

#### 구현
- turnover()는 압축 정보를 담은 문자열을 파라미터로 받는다. 주어진 쿼드트리의 자식격인 쿼드쿼리 4개를 얻는다면 위치를 상하반전하여 합친 후 반환한다.
- turnover()가 받는 문자열 picture은 완전한 쿼드 트리는 아니다. 이런 구현이 가능한 이유와 만약 완전한 쿼드 트리를 전달하도록 구현했을 때 비효율적인 이유에 대해 설명해 보겠다.
- **turnover()와 같은 구현이 가능한 이유:** 우선 picture의 첫번째 글자가 x인 경우 자식격인 쿼드 트리 4개가 무조건 존재한다. **반복문을 이용해서 4개의 유효한 쿼드 트리만을 찾아낸다면 이 turnover()는 종료한다.** 따라서 완벽한 쿼드 트리가 전달되지 않아도 된다. 또한 반복문을 이용해 자식 쿼드 트리 4개를 구할 때도 turnover()를 이용한다는 점도 주목할만 하다.
- **turnover()에 완전한 쿼드 트리를 파라미터로 받는다면 비효율적인 이유:** 만약 turnover()가 완전한 쿼드 트리를 파라미터로 받는다면 그 전에 쿼드 트리를 분할해야만 한다. 트리 등의 자료구조를 사용해 쿼드 트리를 만들고 turnover()를 처리해도 되겠지만 **쿼드 트리를 분할하느라 재귀 호출, 병합하느라 다시 재귀 호출하는 꼴이 되버려 비효율적이다.**
- 위 경우에서 트리를 사용하지 않는다고 하면 쿼드 트리의 분할 과정에서 중복적으로 구조를 파악해야만 하는 부분이 생기게 되므로 더 비효율적이다. 

### 문제
- turnover()에 넘겨주는 파라미터를 완전한 쿼드 트리로 할 것인가? 만약 그렇다면 분할을 어떻게 할 것인가? 만약 분할을 재귀호출을 통해 한다면 병합도 재귀호출인데 어떻게 처리할 것인가?
- 분할과 병합을 한 번에 처리하려면 어떻게 해야하는가? x를 만나면 바로 재귀 호출하는 식으로 구현하면 안될까? 
- turnover()에 넘겨주는 파라미터를 완전한 쿼드 트리로 하지 않는다면 어떻게 구현해야 하는가? 쿼드 트리에 끝이 표시되지 않는데 그렇게 구현해도 되겠는가?

### 다른 코드와의 비교

#### 솔루션

##### 문제 해결의 발전 과정
1. 이 문제를 해결하기 위한 가장 무식한 방법은 쿼드 트리를 압축 해제하여 상하반전한 뒤, 다시 압축하는 방법이다. 쿼드 트리가 재귀적으로 정의되어 있기 때문에 쿼드 트리를 압축/해제하는 과정은 재귀 호출로 구현하는 것이 자연스럽다.
2. 주어진 쿼드 트리의 첫번째 문자가 'x'일 때, 나머지 부분을 4개로 쪼개는 것은 쉽지 않다. 각 부분의 길이가 일정하지 않기 때문이다.
3. 위를 해결하기 위한 방법으로 재귀 호출을 이용해 각 부분의 길이를 반환하는 getChunkLength()와 같은 함수를 작성할 수 있다. 이는 비슷한 일을 하는 두 개의 함수를 각각 작성한다는 점에서 별로 마음에 들지 않는다.
4. 이를 해결할 수 있는 패턴으로 미리 쪼개는 것이 아니라 **'필요한 만큼 가져다 쓰도록'** 하는 것이다.
5. 하지만 압축을 푸는 방법은 메모리를 너무 쓴다는 결점이 있다.
6. 이런 경우에는 압축을 해제한 결과를 메모리에 다 저장하는 대신 **결과 이미지를 뒤집은 결과를 곧장 생성하는 코드를 작성하는 것이다.**

##### 차이점
- 내 코드에서는 start라는 변수를 통해 시작점을 조절함으로써 구현했지만 솔루션에서는 string::iterator를 사용해 한 문자를 검사할 때마다 이 포인터를 앞으로 한 칸씩 옮기는 식으로 구현했다.


#### 다른 코드
- 뭔가 숫자를 사용해서 기괴하게 짠 코드도 있네..


### 느낀점
- 시간복잡도 구하기는 어렵다.
- 분할 정복과 관련한 문제를 풀 때는 간단한 예시를 만들어서 점진적으로 해결해나가는 것도 좋은 방법일 것 같다.
 