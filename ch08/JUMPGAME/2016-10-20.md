## JUMPGAME

- 코드수정 0번
- 제출 0번
- 소요시간 1시간 15분
- 문제 해결 성공

### 접근방법
동적 계획법을 사용해 문제를 해결함

#### 구현
- 문제에 따르면 (0, 0)에서 시작해 (N-1, N-1)으로 이동하는 데 각 칸에 적혀 있는 수만큼 오른쪽 혹은 아래로만 진행할 수 있다. 각 칸에 적혀 있는 수를 map이라는 배열에 저장한다고 하자. 
- 예를 들어 내가 (a, b)에 있다고 할 때 (a, b+map(a, b))나 (a+map(a, b), b)로만 이동할 수 있다.
- 위 성질과 시작점이 (0, 0)이라는 점을 이용해서 (0, 0)에서 이동할 수 있는 칸을 고를 수 있다. 이 때, 이동 가능한 지의 여부를 cache라는 배열에 저장한다고 하면 cache(0, 0) = 1이 되고, cache(0, map(a, b)) = cache(map(a, b), 0) = 1이 된다.
- (0, 0)부터 (N-1, N-1)까지 순회하면서 이동할 수 있는 칸을 확장시킨다.
- 이 때, 임의의 점(x, y)에 이동할 수 있는 방법은 한 가지 이상일 수 있기 때문에 cache(x, y)에 이동할 수 있다면 1을 더해주는 식으로 처리한다.
- 순회가 끝났을 때 cache(N-1, N-1)가 0보다 크다면 이동 가능한 것이다.

### 문제
- '분할정복'과 비슷하게 우선 문제를 분할해야 하므로 어떻게 분할해야 할지에 대해 고민했다.
- '분할정복'과 비슷한 느낌으로 재귀 호출할 함수를 구현하려 했으나 7장에 나왔던 문제들과는 다소 다른 부분이 있었다.
- 우선, 문제의 분할 방법이 여러가지였다. 예를 들어 (0, 0)->(3, 3)이라고 하면 (0, 0)->(0, 3)+(0, 3)->(3, 3)과 (0, 0)->(3, 0)+(3, 0)->(3, 3)로 나눠졌다.
- 또한 '동적 계획법'을 이용해서 풀어야 할 것 같은데 위 구현을 가지고는 cache[a][b]의 의미를 정할 수 없다는 생각이 들었다. 위 구현을 함수로 만들면 solve(startX, startY, endX, endY)의 꼴이 되야 하는데 이 함수에서 구한 값을 cache[a][b]에 저장히기는 애매하다.


### 다른 코드와의 비교

#### 솔루션
- 아마도 내 구현은 **반복적 동적 계획법**인 것 같다.
- 동적 계힉법 알고리즘을 만드는 첫 단계는 **해당 문제를 재귀적으로 해결하는 완전 탐색 알고리즘을 만드는 것**이다.
- 이 문제에서 완전 탐색 알고리즘은 맨 왼쪽 윗 칸에서 시작하는 모든 경로를 한 번의 함수 호출에서 하나씩 만들면서 마지막 칸에 도달할 수 있는지를 검사하는 것이다. 이 때 함수는 아래와 같은 꼴로 만들 수 있다. 
- jump(y, x) = (y, x)에서부터 마지막 칸에 도달할 수 있는지 여부를 반환한다.
- 내 경우에는 시작점과 끝점을 매개변수로 받는 함수를 짜려고 해서 구현이 힘들었으나 솔루션에서는 끝점을 맨 마지막 칸으로 고정시킨 후 시작점만 매개변수로 받는 함수를 만들었다.
- 솔루션에서는 최악의 경우 (n=100이고 이동 거리가 모두 1일 때) 완전 탐색으로 만들어야 하는 경로의 개수는 n에 대해 지수적으로 증가한다고 나와 있는데 이는 jump()에서 2번의 jump()를 호출하고, 마찬가지로 그 두 jump()에서도 2번의 jump()를 호출하는 과정이 계속 이어지기 때문이다.
- 이런 식으로 경로를 2^n개 만든다고 할 수 있는데 jump()에 매개변수로 들어갈 수 있는 값은 총 n*n개이므로 **비둘기집의 원리에 의해 중복인 부분 문제들이 있다는 것을 알 수 있다.** 또한 jump()는 참조적 투명 함수이기 때문에 메모이제이션을 적용해서 중복된 연산을 줄일 수 있다.
- 대개 동적 계획법 알고리즘의 구현은 다음과 같은 두 단계로 이루어진다.
- **1. 주어진 문제를 완전 탐색을 이용해 해결한다.**
- **2. 중복된 부분 문제를 한 번만 계산하도록 메모이제이션을 적용한다.**


### 느낀점
- 어떻게 구현해야 할지 확실히 떠오르지 않으면 코딩을 시도해보는 것도 나쁘지 않을지도..?
- 재귀 호출을 구현하기 위해서는 다른 조건은 모두 고정시키고, 한 조건만 유동적으로 해야한다는 생각이 들었다..
 