## PICNIC

- 코드수정 3번
- 제출 1번
- 소요시간 2시간
- 문제 해결 성공

### 접근방법
완전 탐색을 사용해 문제를 해결함

#### 조각
남은 학생들 중에서 짝 지어주기

#### 기저사례
1. 모든 학생들이 짝이 되었을 경우
2. 남은 학생들이 있지만 그 학생들끼리 친구가 아닌 경우

#### 구현
- bool형 2차원 10X10 배열 areFriends에 서로 친구인지의 여부를 저장한다. 이 떄 만약 i와 j가 친구라면 areFriends[min(i, j)][max(i, j)] = true가 되도록 한다. 이렇게 구현함으로써 (i, j)와 (j, i)의 구분을 할 필요가 없어진다.
- bool형 1차원 배열 coupled에 그 학생이 짝이 있는지 여부를 저장한다. 이 배열을 통해 기저사례 1에 대한 판단을 할 수 있다.
- 다음 매칭할 학생을 고르기 위해 아직 짝이 없는 학생이 나올때까지 coupled를 순회한다. 아직 짝이 없는 학생이 있다면 그 학생을 from이라고 한다.
- areFriends에서 from과 친구인 to를 찾는다. 있다면 coupled[from]=coupled[to]=true로 해준 후 나머지 짝을 지어주기 위해 재귀 호출한다.

### 문제
- coupled 배열의 초기화를 제대로 하지 않았다.
- areFriends[from][to]==true인 모든 to에 대해 짝을 지어줘서 문제가 됐다. (이 문제를 해결하기 위해서는 coupled[to] == false인 조건도 포함되어야 한다.)

### 다른 코드와의 비교

#### 솔루션
- 솔루션에서는 문제를 어떤 조각으로 나눌지 - **한 조각마다 두 학생을 짝지어 준다** -, 문제의 형태가 어떤지 - **아직 짝을 찾지 못한 학생들의 명단이 주어질 때 친구끼리 둘씩 짝짓는 경우의 수를 계산하라** - 에 대해 명확히 명시하고 있다.
- 경우의 수를 세는데 발생할 수 있는 중복에 대해 더 자세히 생각하며 이를 어떻게 제거할 것인지에 대해 논하고 있다. (**각 조각에서 남아 있는 학생들 중 가장 번호가 빠른 학생의 짝을 찾아주도록 구현해 중복을 제거하고 있다.**)

#### 다른 코드
- 배열 초기화는 bool areFriends[10][10] = {false}와 같이 편하게 할 수 있다.
- cin을 사용하기 전에 scanf를 사용할 수는 없는지 다시 생각해 본다.


### 느낀점
- 데이터들을 어떤 형태로 저장할 것인지, 그리고 어떻게 초기화하고 관리할 것인지에 대한 감이 부족하다.
- 재귀를 통한 완전 탐색을 할 때 함수에서 기본적으로 수행해줘야 하는 작업을 어떻게 구현해야 하는지에 대한 감이 부족하다.
- 문제를 푸는데 집중력이 많이 부족하다.
 